<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html> <head>
<title></title>
</head>
<h1>Introduction to Communicating: Connecting Devices via Bluetooth Sockets</h1>
<h4>Christine Julien, The University of Texas at Austin</h4>
<p>&nbsp;</p>

<p>We've already seen some basic communication between devices (e.g., when we used the CLIP webpage to send RESTful commands to the hue light or when our Android application used the provided Java programming abstractions&nbsp;to control the hue light). In those cases, the Android phone was talking to the hub via WiFi, then the hub is sending commands to the lights via the Philips proprietary communication protocol. In this module, we'll take a look at another option for communication among our components, with a specific focus on getting connectivity to and from the Raspberry Pi. We'll look specifically&nbsp;at Bluetooth communication, which will allow our Android device to communicate directly with the Raspberry Pi. This exercise is based heavily on <a href="http://blog.davidvassallo.me/2014/05/11/android-linux-raspberry-pi-bluetooth-communication/">this</a> blog post.</p>
<p>There are also other possibilities for connecting the RPi to the Internet, having the RPi store data in the Internet (usually through a RESTful API) and then having an Android application retrieve that data from the same Internet server (again, through a RESTful API). There are some links at the end that lead you to some tutorials if you want to try that out.&nbsp;</p>
<h3>Bluetooth</h3>
<p>Bluetooth will work out of the box on both the Android device and the Raspberry Pi that we're using. However, to be able to&nbsp;write Python programs on the RPi that use Bluetooth, we need some extra packages. Specifically, we're going to use something called Bluez, which is a commonly used Bluetooth protocol stack in Linux (and it works great on the RPi too!). Then we're also going to need a library called PyBluez, which is (not surprisingly) a<span> Python API for accessing the bluetooth resources using that&nbsp;Bluez&nbsp;exposes.</span></p>
<p><span>To get these installed, we're going to use a tool called apt-get which is also commonly used in Linux environments to install and build packages. It's much easier than doing all of this installation by hand.</span></p>
<p><span>So head on over to the VNC connection to the Raspberry Pi and open up a terminal. Type the following at the command line:</span></p>
<pre><code>sudo apt-get install bluetooth bluez
</code></pre>
<p><span>This will install Bluez. When asked if you want to continue, select Y (for Yes). It's likely that Bluez is already installed, but this will make sure you have the most recent version.</span></p>
<p><span>Next, type:</span></p>
<pre><code>sudo apt-get install python-bluez
</code></pre>
<p><span>This will install the python API for accessing Bluez.</span></p>
<p><span>There's one other setting on the RPi that we need to "fix" to make two-way communication work. Specifically, we're going to use a serial port connection between the two devices, so we need to make the RPi aware of the serial port profile. We need to edit the bluez service file. So type:</span></p>
<dl class="codebox">
<dt>
<pre><code>sudo nano /etc/systemd/system/dbus-org.bluez.service</code></pre>
</dt>
</dl>
<p><span>Find the line that starts with ExecStart= and add&nbsp;' -C' at the end of the line. This will cause the bluetooth daemon to start in "compatibility" mode. Next, add a new "ExecStartPost=" immediately after that line, to add the serial port (SP)&nbsp;profile. The two lines should look like this:<br /></span></p>
<dl class="codebox">
<dt>
<pre><code>ExecStart=/usr/lib/bluetooth/bluetoothd -C<br />ExecStartPost=/usr/bin/sdptool add SP</code></pre>
</dt>
</dl>
<p><span>Save (type Ctrl-X for eXit then Y to save) and reboot (type sudo reboot in the terminal). Now when the RPi reboots, the serial port profile will be available. (And it will still be available the next time you reboot, and the next time, etc...)</span></p>
<p><span>For security reasons, Bluetooth devices will only talk to each other after&nbsp;they have been "introduced". This process is called "Pairing". To making pairing possible, we first need to make sure Bluetooth is on. You can do this in the taskbar at the top of the RPi desktop. Click on the Bluetooth icon and make sure it's on. Next, our RPi needs to be <em>discoverable</em> by other devices (notably, the Android device). You can also do this through the task bar at the top of the desktop; just click the Bluetooth icon and select the option "Make discoverable".</span></p>
<p><span>If you want to do this through the command line, type:</span></p>
<pre><code>sudo hciconfig hci0 piscan
</code></pre>
<p><span>If you want to check to see if this worked, type</span></p>
<pre><code>sudo hciconfig -a</code></pre>
<p>You should see this line somewhere in the output:</p>
<pre><code>UP RUNNING PSCAN ISCAN</code></pre>
<p>In that same output, you'll see that the device name is something very clever called "raspberrypi". Since we've got a lot of us with these raspberry pis, we'd rather that name be something different. There are a couple of ways to&nbsp;make this happen, but since we want it to be permanent (even on reboot), let's do the permanent way. Type</p>
<pre><code>sudo ls /var/lib/bluetooth</code></pre>
<p>This will "list" the contents of the bluetooth directory located at this location. It will contain a single folder, and the name of that folder will be a MAC address. (This MAC address should match the one on the sticker on the side of your RPi.) Now type:</p>
<pre><code>sudo nano /var/lib/bluetooth/&lt;MACADDRESS&gt;/config</code></pre>
<p>Include the entire MAC address, verbatim, including the colons. Be careful because sometimes the letter B and the letter 8 look a little the same. This command will open up an empty file for editing. We just need to add one line:</p>
<pre><code>Name='NewDeviceName'</code></pre>
<p>For instance, I typed</p>
<pre><code>Name='ChristinesRPi'</code></pre>
<p>You should use something different within the quotes (no spaces, though!). Now, back at the terminal, type sudo reboot to make these settings take effect. Once the RPi reboots, rerun the command:</p>
<pre><code>sudo hciconfig -a</code></pre>
<p>And you should see that the device name has changed. Because you rebooted, you'll also need to make your device discoverable again, now that we're ready to discover it from the Android device. You can do this again with the GUI menu or with the command line</p>
<p>OK. Now let's make a connection. Grab an Android device. Pull down on the top of the screen twice, and you'll see options for controlling Bluetooth. Click on the little downward pointing triangle next to Bluetooth. Then click "More Settings". Make sure the Bluetooth switch is turned "On". The Android phone should start scanning for devices. If it doesn't, click the three vertical dots at the upper right and select "Refresh". Your (fancy named) RPi should show up in this list. If you do not see your device, head back over to VNC and make sure that it is still set to be discoverable (by default, the RPi only stays in discoverable mode for 3 minutes). Once the RPi shows up in the list on Android, click on the device in the list. This will initiate the pairing process. You'll have to confirm (in VNC) on the RPi that you want to complete this process. And now these devices are friends! You will get an error message on the RPi that the devices didn't connect. That's ok. We're going to use a different mechanism for the connection, but they are now paired and won't have to make friends again, hopefully ever.</p>
<p>Next we want to see if we can send some data across this connection. Specifically, let's write a simple Android application that has just one button. When the button is pressed, the Android device will send a "request" to the RPi, asking the RPi to send back a message. The RPi will send back a fixed message with a counter ("Hello World! [1]"), which the Android device will simply display to the screen. Each time the button is pressed, the counter after "Hello World!" should increment. In this example, the RPi will be our&nbsp;<em>server</em>, and the Android phone will be the&nbsp;<em>client</em>. That is, the RPi will provide a service that the Android phone connects to and uses. We can send data in both directions across this connection, but we need each device have&nbsp;a well-defined role so they don't get confused.</p>
<p>To do this, we need some new code on each side. That is, we're going to need an Android project on the phone and we're going to need a python script on the RPi. Let's start with the latter (it's a bit easier, or at least a bit less involved).</p>
<p>Inside your VNC window, open up the Python editor and create a new file. Let's go ahead and save the (empty) file. Let's call it bluetoothtest.py.</p>
<p>At the top of this file, type the line</p>
<pre>from bluetooth import*</pre>
<p>This will get us access to all of the bluetooth libraries for programming on the RPi.</p>
<p>We're going to do our programming with something called&nbsp;<em>sockets</em>.&nbsp;<span>Sockets are just simple communication points located on the same or different computers that are used to exchange data. Sockets are supported my most operating systems, so it's a natural abstraction to learn. To use them, we'll need to understand addresses and ports, and we'll also need to understand the basic function of a socket.</span></p>
<p>The two endpoints of a socket are two processes. These processes can be on the same or different machines; in our example, one process will be on the RPi and the other on Android. Sockets allow the two processes to "talk" to each other using "file descriptors". That is, once the socket is all set up, the processes can just "read" from and "write" to the socket, as though it were an open file.</p>
<p>We're going to use the BluetoothSocket provided by the python libraries for Bluetooth programming, and we're going to wrap it around a serial connection called RFCOMM. This serial connection is set up for us when our devices connect over bluetooth (because we modified the RPi's Bluetooth configuration to enable the serial connection).</p>
<p>So the next lines in your RPi python script are going to create and initialize the socket. Type:</p>
<pre>server_sock = BluetoothSocket(RFCOMM)<br />server_sock.bind(("",PORT_ANY))<br />server_sock.listen(1)</pre>
<p>If you want to browse it, the documentation for pyBluez is <a href="http://htmlpreview.github.io/?https://github.com/karulis/pybluez/blob/master/docs/index.html">here</a>; this will allow you to easily see what functions are available, though the documentation itself is not particularly detailed. But you might be able to get a sense of what's happening. The first line here defines a new variable called server_sock and creates a new BluetoothSocket using a serial connection. The second line "binds" this socket to a specific port on a specific host. The bind method takes a "tuple" (in this case, a pair of two values). The first value is the host address and the second value is the port to use. In this case, we only have one bluetooth adapter, so we can leave the hostname empty (and the system will figure it out). We can also leave it up to the system to pick an available port, so we use "PORT_ANY". Finally, we want to put the socket in "listening" mode so that it will accept incoming connections. The 1 here indicates that we're willing to accept just one connection at a time.</p>
<p>First, we need to create a "universally unique identifier" (a UUID) to identify the service. A UUID is used in Bluetooth to identify a particular service provided by a Bluetooth device. Our RPi will provide the service; our Android device will have to know the same UUID in order to connect to the service provided by the RPi.</p>
<p>We're going to use the Bluetooth "base uuid", combined with a preceding 00001101, which identifies the use of the serial port. To create this uuid in the python script, type the following in your python editor:</p>
<p>uuid = "<span>00001101-0000-1000-8000-00805f9b34fb"</span></p>
<p><span>Next, we'll use this UUID to set up a service that we can advertise to other parties who might want to connect to our service. Type the following:</span></p>
<pre><span>advertise_service(server_sock, "ChristinesPiServer",<br />                  service_id = uuid,<br />                  service_classes = [uuid, SERIAL_PORT_CLASS],<br />                  profiles = [SERIAL_PORT_PROFILE],<br />                 )</span></pre>
<p><span>This statement advertises the service on the server_sock we've already declared and gives it a friendly name (you can use whatever name you want). It associates the uuid we defined as the service_id, and it will use a serial port for the connection, along with the serial port profile.</span></p>
<p><span></span><span>Now we move on to the main body of our program. Before that, though, let's declare a counter variable that we'll increment everytime we send "Hello World!" to the client. Type the following line:</span></p>
<pre><span>counter = 0</span></pre>
<p><span>As in our previous programs, we'll run an infinite loop (while True:) that can be interrupted by a keyboard input (i.e., CTRL-C). We're going to also add some print statements just so we can keep track of where we are in the program. Let's start with the following few lines:</span></p>
<pre><span>while True:</span><br /><span>&nbsp; &nbsp; print "Waiting for connection on RFCOMM"</span><br /><span>&nbsp; &nbsp; client_sock, client_info = server_sock.accept()</span></pre>
<p>The accept method is called on a socket when the socket is ready to accept connections from the other endpoint. At this point, our program will just sit and wait for someone (eventually, this will be our Android program) to connect. That is, the accept&nbsp;method is&nbsp;<em>blocking</em>. When it (successfully) returns, our socket will&nbsp;connect us to some other process. All of the rest of this code happens&nbsp;<em>after</em> that connection. Once the program accepts a connection, it will provide a service to the connecting process, then it will cycle back around and execute this loop again, i.e., wait to accept another connection.</p>
<p>When a connection is&nbsp;<em>accepted</em>, the method returns a handle to the client socket (client_sock, in our program), which we can use later to communicate with the client (that'll be the Android device). It also returns some information about the client device (client_info).</p>
<p>Next, we'll try to receive some information from our client. We'll do this inside a "try" block because errors (i.e., "exceptions") can happen with our socket and we need to be able to deal with them. Type the following:</p>
<pre>print "Accepted connection from: ", client_info<br />try:<br />&nbsp; &nbsp; data = client_sock.recv(1024)</pre>
<p>Here, we first print out some information about the client device that connected to our service. Then, inside our try block, we call the recv ("receive") method on our client socket. We attempt to receive up to 1024 bytes, and we store the data received in a variable called data.</p>
<p>If, for some unknown reason, the data that we receive is empty let's just ignore it and go back to accept another connection. On the other hand, if the text we receive is "Hello?", we want to send back "Hello World!" with an incremented&nbsp;counter. If the text is anything else, let's send back "What?" instead. Here, you can see all of the logic in the context of the while loop.</p>
<pre>while True:<br />    print "Waiting for connection on RFCOMM"<br />    client_sock, client_info = server_sock.accept()<br /><br />    print "Accepted connection from: ", client_info<br />    try:<br />&nbsp; &nbsp;     data = client_sock.recv(1024)<br />        if len(data) == 0: break<br />        print "received [%s]" % data<br />        if data == 'Hello?':<br />&nbsp; &nbsp;         counter += 1<br />&nbsp; &nbsp;         data = 'Hello World [' + str(counter) + ']!'<br />        else:<br />&nbsp; &nbsp;         data = "What?!"<br />        client_sock.send(data)<br />        print "sending [%s]" % data<br /><br />    except IOError:<br />        pass<br /><br />    except KeyboardInterrupt:<br />        print "disconnected"<br />        client_sock.close()<br />        server_sock.close()<br />        print "all done!"<br />        break</pre>
<p>Just to note a few things here that are likely new. First, our new print statement uses "%s" to indicate that there is a string (a sequence of characters) that it wants to print out; the print statement is followed by the specific string to print (i.e., data).</p>
<p>Then we have an if/else block. Here, we first check to see if the if block is allowed (e.g., if the data's content is exactly the string "Hello?"). If that's the case, we perform the two lines underneath the if. If that condition is not true (i.e., the string as&nbsp;<em>anything&nbsp;</em>else), then the server does the line under the else statement.</p>
<p>In both cases, we're constructing a string to send back; we use the same "data" object because, well, why not? In the first case, we first increment the counter (counter += 1 means "add one to the current value of the counter"). The statement "str(counter)" turns this value into a string. Notice that both of the strings we send back end in an "!". We're going to use this on the client later to find the "end" of a message.</p>
<p>After the if/else statements, we then simply call "send" on the client socket with whatever data we constructed to send back.</p>
<p>We have two exceptions to handle. One is an IOError. We have to "catch" these exceptions in case something goes wrong with our socket; in this case, we'll do nothing, though. Second, we "catch" the keyboard interrupt, just like we did in previous exercises. The most important thing to do before we just quit is to "clean up" our sockets so we leave everything in a good state. In this case, we just need to close both sockets. Then we're done!</p>
<p>Again, this is all running in an "infinite loop" meaning after each "send" from the server, it goes back to the top of the while loop and waits to accept another connection from the client. It continues to do this until it receives the keyboard interrupt.</p>
<p>Alright, let's save this file (select File &gt; Save or press CTRL-S). We can't really do much with this right now since we don't yet have a client to connect to it. But we can do a quick sanity check (basically check to see if we have any typos). To do that, go out to the terminal window and type&nbsp;</p>
<pre>sudo python bluetoothtest.py</pre>
<p>You should see it print that it's "Waiting for connection on RFCOMM", but it won't do anything else yet.</p>
<p>Now, let's create a client.</p>
<p>Open up Android studio. Let's make a new project (File &gt; New &gt; New Project). Let's call the Application Name "Bluetooth Test App". You can leave the company domain the default (example.com) and use the default location for the project files. Click Next. Let's use API 21 (Lollipop) as the API level (some of the Bluetooth features have changed recently in Android), and we're just doing a Phone/Tablet app. Click Next. On the next screen, stick with the default (we'll create an "Empty Activity"), so click Next. And we can keep the default MainActivity.java. So click Finish.</p>
<p>Let's set up the layout first. We're going to have a very simple layout with a single button and a text view. When we press the button, we want to send a message across a bluetooth connection to the RPi; the RPi should send a response, which we want to display in the text view. Click on the activity_main.xml tab near the top of the window, then switch it to the design view. By default, you already get a text view in the center of the layout. Let's move it nearer to the top. We can leave its default text as "Hello world", but let's make it a little bit bigger.</p>
<p>Add a Button underneath the text view. Set the button's text to "Send Request". Move things around in the layout until you think you're happy with it; feel free to launch this shell of a program into the emulator or onto a phone to see if you're happy with how it looks.</p>
<p>Alright. Now let's make that button do something. Click on the MainActivity.java tab so we can write some code. You won't see much here yet besides the onCreate method that just sets up the layout.</p>
<p>In this project, we're going to create some worker "threads" to handle the bluetooth activities so that they don't block our main UI thread. This is generally a good idea; not doing so can render the UI unresponsive, which can result in angry users. There are multiple ways to achieve this; in this simple case, we're just going to create a "Runnable" object that we can "run" when we're ready to do some Bluetooth activity. From the reverse direction, when we want to update the UI, we're also going to delegate that task to a "Handler" so other user interactions can continue. First, let's declare this generic UI handler. <span>Above the onCreate method (right below the line that declares the MainActivity class) add the line:</span></p>
<pre><span>final </span><span>Handler</span> handler = <span>new </span><span>Handler</span>();</pre>
<p>You'll get that error that Android studio can't resolve the symbol; attempting the "quick fix" (recall, press ALT + ENTER) will present you with two choices; you want the Handler that is in the android.os package. [You'll get these errors every time you add something new; I'm assuming you now know how to resolve them, and I will just skip over this step from now on.]</p>
<p>Next, before we get started with the detailed code, we also need to initialize our Bluetooth connection. Just below where you declared the handler, add the following two lines:</p>
<pre>BluetoothSocket <span>mmSocket</span>;<br />BluetoothDevice <span>mmDevice </span>= <span>null</span>;</pre>
<p>These declare a BluetoothSocket (which is the Android analog to what we saw on the RPi) and a BluetoothDevice (which will give us a handle to the remote&nbsp;Bluetooth device; in our case the RPi). Next, let's make sure the Bluetooth is turned on and ready to go. In the onCreate method (after the declaration of the Handler), add the following line:</p>
<pre>BluetoothAdapter <span>mBluetoothAdapter</span> = BluetoothAdapter.<span>getDefaultAdapter</span>();</pre>
<p>This will just ask the local Android system for the Bluetooth adapter. We can then use it to send and receive via Bluetooth. But only if Bluetooth is on on the phone. Next, we'll check for that in our program. Add the following lines:</p>
<pre><span>if</span>(!mBluetoothAdapter.isEnabled()){<br />    Intent enableBluetooth = <span>new </span>Intent(BluetoothAdapter.<span>ACTION_REQUEST_ENABLE</span>);<br />    startActivityForResult(enableBluetooth, <span>0</span>);<br />}</pre>
<p>If Bluetooth is not enabled on the phone, this code launches a new "Intent" (like we did manually in the Android example exercise). This intent presents the user with a request to enable bluetooth.</p>
<p>In the Android studio window, you'll notice that "mBluetootAdapter.isEnabled()" is underlined in red and that there is a red lightbulb to the left of the line. This lightbulb is telling us that our application hasn't requested "permission" to access bluetooth. We can resolve this by clicking on the red lightbulb and then selecting "Add permission bluetooth". Permissions in Android are a messy thing. You can get a lot more details <a href="https://developer.android.com/guide/topics/permissions/index.html">here</a>. But really briefly, let's look at what happened when we resolved this bluetooth permission. In the project window in Android Studio, expand the "manifests" list. Then double click AndroidManifest.xml to open it up. On about line 5, you should see that the manifest declares the bluetooth permission. Now when anyone downloads and installs your application, the system will first announce that the application requests the bluetooth permission and require the user to acknowledge that the app can access bluetooth.</p>
<p>OK. You can close AndroidManifest.xml and go back to MainActivity.java.</p>
<p>Next up, we want to set up mmDevice to point to our (paired) RPi device. For this, you'll need to know the name of the RPi Bluetooth device. Here's the code that you want to add to the end of your onCreate method.</p>
<pre>Set&lt;BluetoothDevice&gt; pairedDevices = mBluetoothAdapter.getBondedDevices();<br /><span>if</span>(pairedDevices.size() &gt; <span>0</span>) {<br />    <span>for</span>(BluetoothDevice device : pairedDevices) {<br />        <span>if</span>(device.getName().equals(<span>"raspberrypi"</span>)) { <span>//Note, you will need to change this to match the name of your device{<br /></span><span>            </span><span>mmDevice </span>= device;<br />            <span>break</span>;<br />        }<br />    }<br />}</pre>
<p>First, this gets the set (just a data structure that contains a bunch of things) of devices that are already paired with this bluetooth device. Because we've already paired the RPi with the Android device, this set will contain at least one thing... our RPi. Then, as long as we have at least one paired device (the if statement), we look at each of the paired devices in turn (the for loop). We examine the "name" of the paired device to see if it matches the one we're looking for. You'll need to make the string here equal to the name of your RPi device (the name that is displayed when you type "sudo hciconfig -a" in the terminal on your RPi. When we find the matching device, we store it in the mmDevice variable we declared earlier. And now we can try to talk to it!</p>
<p>We don't want our program to do anything until the user clicks the button; then we want to send a message to the RPi via our bluetooth connection. So we need to set a "listener" for "clicks" of the button. This is very similar to what we saw with the Philips Hue light example. So, still in our onCreate method, we want to add the following (don't worry; you won't be able to resolve the last conflict in this one; we still have some more work to do):</p>
<pre><span>final </span>Button button = (Button) findViewById(R.id.<span>button</span>);<br />button.setOnClickListener (<span>new </span>View.OnClickListener() {<br />    <span>public void </span>onClick(View v) {<br />        <span>// Perform action on temp button click<br /></span><span>        </span>(<span>new </span>Thread(<span>new W</span>orkerThread(<span>"Hello?"</span>))).start();<br />    }<br />});</pre>
<p>The first line gets a handle to the button (make sure that what follows R.id. matches the id of your button in activity_main.xml). Then we set a listener for clicks of the button. When the button is clicked, the onClick method will be called. When that happens, we're going to make a Thread and start it. That thread is of type WorkerThread; we still have to define what a WorkerThread is and what it should do.</p>
<p>Our WorkerThread needs to do two things: first it needs to send the bluetooth message to the RPi. Then it needs to wait to hear a response from the RPi. Conceptually, these are straightforward, but they take a few lines of code to write. Before we write the worker thread, let's write a helper method that can send a message to mmDevice.</p>
<p>Below&nbsp;is the code for that method. You need to put it inside the MainActivity class but outside of the onCreate method:</p>
<pre><span>public void </span>sendBtMsg(String msg){<br />    UUID uuid = UUID.<span>fromString</span>(<span>"00001101-0000-1000-8000-00805f9b34fb"</span>); <span>//Standard SerialPortService ID<br /></span><span>    </span><span>try </span>{<br />        <span>mmSocket </span>= <span>mmDevice</span>.createRfcommSocketToServiceRecord(uuid);<br />        <span>if </span>(!<span>mmSocket</span>.isConnected()){<br />            <span>mmSocket</span>.connect();<br />        }<br />        OutputStream mmOutputStream = <span>mmSocket</span>.getOutputStream();<br />        mmOutputStream.write(msg.getBytes());<br /><br />    } <span>catch </span>(IOException e) {<br />        e.printStackTrace();<br />    }<br />}</pre>
<p>Let's quickly walk through what it's doing. This is a method that takes a String message and sends it across a bluetooth socket. First, you should recognize that first line. we're declaring a UUID much like we did in the python script, and we're using exactly the same UUID (so that we connect to the right service on the RPi).</p>
<p>Next, we're creating our socket endpoint, again using the serial RFCOMM connection like we did on the RPi. The specific syntax for doing this in Java/Android is a little bit different, but the purpose is the same. Then, if the socket isn't already connected, we call connect() on the socket. This is a super important and very cool step. Calls to "connect" on one end of a socket match up to calls to "accept" on the other end. So it is exactly this call that will "unblock" the python script waiting on the other end. Once the "connect" completes, the two devices will both be in send/receive mode on the same socket. However, unlike accept, connect is usually not blocking. Which means that the other side (the server) has to be waiting&nbsp;<em>before</em> the client attempts to connect.</p>
<p>After we're connected, we simply create an "output stream" (which you should think of as just a&nbsp;channel through a pipe where you can send data as though its a stream of water) and send the data (i.e., the message) to the stream.</p>
<p>We do all of this work inside of a try block because if something goes wrong with our connection or our stream while we're in the middle of working with them, they'll cause "exceptions" that we have to catch. In this case, the primary exception is an "IOException" (Input/Output Exception).</p>
<p>OK. Our last step is to create our WorkerThread class. It will be a class-inside-of-a-class because it's behavior is very specific to our little Bluetooth test app. So you declare this class before the "}" that ends the MainActivity class (i.e., at the same "level" as a method within the MainActivity class). Let's start with this skeleton of the WorkerThread class:</p>
<pre><span>final class W</span>orkerThread <span>implements </span>Runnable {<br />    <span>private </span>String <span>btMsg</span>;<br /><br />    <span>public W</span>orkerThread(String msg) {<br />        <span>btMsg </span>= msg;<br />    }<br /><br />    public void run() {<br />        //TODO<br />    }<br />}</pre>
<p>This declares a class called WorkerThread, which has a single instance variable called "btMsg". This is the message we're going to send across the Bluetooth connection. Remember above when we created the WorkerThread, we set the message to "Hello?". The line "public WorkerThread(String msg)" is a&nbsp;<em>constructor</em> in Java. It is called automatically any time we declare a new instance of the class WorkerThread (which we do in our onClick method). This constructor takes a string message as the parameter; the only thing it does is store that message in the local variable btMsg. Finally, the WorkerThread declares a method called run(). This method is called by the system at some point after the thread is "started". Note that, when we create the WorkerThread inside the onClick method, we call the start() method, which we do not define. This start method is defined in the&nbsp;<em>base class</em>&nbsp;Runnable that our WorkerThread; it does some setup and then calls the thread's run() method.</p>
<p>So our next (and last!) step is to define what the thread should do when it runs. We said it should send a message (specifically, the string that's stored in btMsg), then receive a reply from the server. Here's the beginning of the code for the run method:</p>
<pre><span>    public void </span>run() {<br />        <span>byte </span>delimiter = <span>33</span>;<br />        <span>int </span>readBufferPosition = <span>0</span>;<br />        <span>final </span>TextView btResult = (TextView) findViewById(R.id.<span>textView</span>);<br /><br />        sendBtMsg(<span>btMsg</span>);</pre>
<p>First, the method declares three new variables. The first is a "byte" that has the ASCII value of the character "!". Remember, this is what we're going to look for to indicate the end of a message from the server. Second, we declare a counter to keep track of the bytes of the message we've read; we'll increment this counter as we receive things, then reset it when we see the end of a message. Finally, we get a handle to the text view object in our layout where we want to write the message that we receive. (Again, you need to make sure that what follows R.id. matches the ID associated with your TextView object in activity_main.xml.)</p>
<p>The fourth line of the run() method just calls our send function using the btMsg that was passed to the constructor of the WorkerThread.</p>
<p>Now that we have sent our message, we need to turn around and wait until we receive a message from the server. We keep receiving until we see a "!". So, continuing the run method...</p>
<pre><span style="color: #808080;">    public void run() {</span><br /><span style="color: #808080;">        byte delimiter = 33;</span><br /><span style="color: #808080;">        int readBufferPosition = 0;</span><br /><span style="color: #808080;">        final TextView btResult = (TextView) findViewById(R.id.textView);</span><br /><br /><span style="color: #808080;">        sendBtMsg(btMsg);</span><br /><br /><span>        while</span>(!Thread.<span>currentThread</span>().isInterrupted()) {<br />            <span>int </span>bytesAvailable;<br />            <span>boolean </span>workDone = <span>false</span>;<br />            <span>try </span>{<br />                <span>final </span>InputStream mmInputStream;<br />                mmInputStream = <span>mmSocket</span>.getInputStream();<br />                bytesAvailable = mmInputStream.available();</pre>
<p>This new chunk (starting with the while loop) executes until either (a) the thread is interrupted externally (e.g., by quitting the application) or (b) the work is done (which will be indicated by the workDone variable being set to true. Later in this program, we'll check the value of workDone and exit the loop if its true. This code declares an InputStream using the socket we created previously (which is a analog&nbsp;to the output stream we used in sending) and then asks the stream how many bytes are available. If there are bytes available on the output stream we have some data to process. Continuing:</p>
<pre><span style="color: #808080;">    public void run() {</span><br /><span style="color: #808080;">        byte delimiter = 33;</span><br /><span style="color: #808080;">        int readBufferPosition = 0;</span><br /><span style="color: #808080;">        final TextView btResult = (TextView) findViewById(R.id.textView);</span><br /><br /><span style="color: #808080;">        sendBtMsg(btMsg);</span><br /><br /><span style="color: #808080;">        while(!Thread.currentThread().isInterrupted()) {</span><br /><span style="color: #808080;">            int bytesAvailable;</span><br /><span style="color: #808080;">            boolean workDone = false;</span><br /><span style="color: #808080;">            try {</span><br /><span style="color: #808080;">                final InputStream mmInputStream;</span><br /><span style="color: #808080;">                mmInputStream = mmSocket.getInputStream();</span><br /><span style="color: #808080;">                bytesAvailable = mmInputStream.available();<br /><br /></span><span>                if</span>(bytesAvailable &gt; <span>0</span>) {<br /><span>                    byte</span>[] readBuffer = <span>new byte</span>[<span>1024</span>];<br />                    <span>byte</span>[] packetBytes = <span>new byte</span>[bytesAvailable];<br />                    mmInputStream.read(packetBytes);</pre>
<p>Here, we declare two arrays to hold bytes. The first one, readBuffer can hold up to 1024 bytes. That's good; we know from writing the python script that we're not going to send more than 1024 total per message. The second one is just going to be a temporary hold of what is available (which may or may not be everything up to the "!" at this point). So we'll read the currently available bytes into packetBytes to start with. The next piece is the biggie. We're going to look through the packetBytes to see if we got the "!" (and therefore received an entire message):</p>
<pre><span style="color: #808080;">    public void run() {</span><br /><span style="color: #808080;">        byte delimiter = 33;</span><br /><span style="color: #808080;">        int readBufferPosition = 0;</span><br /><span style="color: #808080;">        final TextView btResult = (TextView) findViewById(R.id.textView);</span><br /><br /><span style="color: #808080;">        sendBtMsg(btMsg);</span><br /><br /><span style="color: #808080;">        while(!Thread.currentThread().isInterrupted()) {</span><br /><span style="color: #808080;">            int bytesAvailable;</span><br /><span style="color: #808080;">            boolean workDone = false;</span><br /><span style="color: #808080;">            try {</span><br /><span style="color: #808080;">                final InputStream mmInputStream;</span><br /><span style="color: #808080;">                mmInputStream = mmSocket.getInputStream();</span><br /><span style="color: #808080;">                bytesAvailable = mmInputStream.available();<br /><br /></span><span style="color: #808080;">                if(bytesAvailable &gt; 0) {</span><br /><span style="color: #808080;">                    byte[] readBuffer = new byte[1024];</span><br /><span style="color: #808080;">                    byte[] packetBytes = new byte[bytesAvailable];</span><br /><span style="color: #808080;">                    mmInputStream.read(packetBytes);<br /><br /></span><span>                    for</span>(<span>int </span>i=<span>0</span>; i&lt;bytesAvailable; i++) {<br />                        <span>byte </span>b = packetBytes[i];<br />                        <span>if</span>(b == delimiter) {<br />                            <span>byte</span>[] encodedBytes = <span>new byte</span>[readBufferPosition];<br />                            System.<span>arraycopy</span>(readBuffer, <span>0</span>, encodedBytes, <span>0</span>, encodedBytes.<span>length</span>);<br />                            <span>final </span>String data = <span>new </span>String(encodedBytes, <span>"US-ASCII"</span>);<br /><br />                            <span>//The variable data now contains our full response (up to "!")<br /></span><span>                            </span><span>handler</span>.post(<span>new </span>Runnable() {<br />                                <span>public void </span>run() {<br />                                    <span>btResult</span>.setText(<span>data</span>);<br />                                }<br />                            });<br /><br />                            readBufferPosition = <span>0</span>;<br />                            workDone = <span>true</span>;<br />                            <span>break</span>;<br />                        }<br />                        <span>else </span>{<br />                            readBuffer[readBufferPosition] = b;<br />                            readBufferPosition++;<br />                        }<br />                   }</pre>
<p>Starting with the for loop, we look through the bytes available one at a time. If the byte we're reading is&nbsp;<em>not</em> equal to "!", we go into the "else" of the for loop (at the bottom), where we simply read the byte into the readBuffer and move onto the next byte. If, however, the byte we just read&nbsp;<em>is</em> equal to "!", then we need to get the entire string and send it back to the UI. This string is stored in readBuffer from the beginning of readBuffer (position 0) up to the position indicated by readBufferPosition. So, first, we make a new byte array that is&nbsp;<em>exactly</em> the size of the received message (an array of size readBufferPosition). We call it encodedBytes. The next line uses the System arraycopy method to copy the contents of readBuffer into encodedBytes. Of course, we only copy the first part of readBuffer (only up until we've copied readBufferPosition number of bytes). Then we take that byte array and make a String out of it, asking the system to use the <a href="http://ascii.cl/">ASCII encoding</a> for the string (ASCII&nbsp;is the most commonly used format for textual data in computing). Next, we send this data to our Handler that will post it back to the UI. Specifically, we ask the handler to run a thread who's entire body is to set the text value of our text view. Finally, we do a little cleanup, resetting readBufferPosition to 0 and setting the workDone variable to indicate that we've finished receiving our entire message and are done with this connection. The "break" command causes us to exit the current loop (in this case, the for loop). Notice that we only break in the case that we received an entire message (up to and including a "!" character).</p>
<p>The rest of our run method is just exiting cleanly and handling any exceptions that may arise:</p>
<pre><span style="color: #808080;">    public void run() {</span><br /><span style="color: #808080;">        byte delimiter = 33;</span><br /><span style="color: #808080;">        int readBufferPosition = 0;</span><br /><span style="color: #808080;">        final TextView btResult = (TextView) findViewById(R.id.textView);</span><br /><br /><span style="color: #808080;">        sendBtMsg(btMsg);</span><br /><br /><span style="color: #808080;">        while(!Thread.currentThread().isInterrupted()) {</span><br /><span style="color: #808080;">            int bytesAvailable;</span><br /><span style="color: #808080;">            boolean workDone = false;</span><br /><span style="color: #808080;">            try {</span><br /><span style="color: #808080;">                final InputStream mmInputStream;</span><br /><span style="color: #808080;">                mmInputStream = mmSocket.getInputStream();</span><br /><span style="color: #808080;">                bytesAvailable = mmInputStream.available();<br /></span><span style="color: #808080;">                <br />                if(bytesAvailable &gt; 0) {</span><br /><span style="color: #808080;">                    byte[] readBuffer = new byte[1024];</span><br /><span style="color: #808080;">                    byte[] packetBytes = new byte[bytesAvailable];</span><br /><span style="color: #808080;">                    mmInputStream.read(packetBytes);<br /><br /></span><span style="color: #808080;">                    for(int i=0; i&lt;bytesAvailable; i++) {</span><br /><span style="color: #808080;">                        byte b = packetBytes[i];</span><br /><span style="color: #808080;">                        if(b == delimiter) {</span><br /><span style="color: #808080;">                            byte[] encodedBytes = new byte[readBufferPosition];</span><br /><span style="color: #808080;">                            System.arraycopy(readBuffer, 0, encodedBytes, 0, encodedBytes.length);</span><br /><span style="color: #808080;">                            final String data = new String(encodedBytes, "US-ASCII");</span><br /><br /><span style="color: #808080;">                            //The variable data now contains our full response (up to "!")<br />                            handler.post(new Runnable() {</span><br /><span style="color: #808080;">                                public void run() {</span><br /><span style="color: #808080;">                                    btResult.setText(data);</span><br /><span style="color: #808080;">                                }</span><br /><span style="color: #808080;">                            });<br /></span><br /><span style="color: #808080;">                            readBufferPosition = 0;</span><br /><span style="color: #808080;">                            workDone = true;</span><br /><span style="color: #808080;">                            break;</span><br /><span style="color: #808080;">                        }</span><br /><span style="color: #808080;">                        else {</span><br /><span style="color: #808080;">                            readBuffer[readBufferPosition] = b;</span><br /><span style="color: #808080;">                            readBufferPosition++;</span><br /><span style="color: #808080;">                        }</span><br /><span style="color: #808080;">                    }<br /></span><span>                    if </span>(workDone){<br />                        <span>mmSocket</span>.close();<br />                        <span>break</span>;<br />                    }<br />                }<br />            } <span>catch </span>(IOException e) {<br /><span>                </span>e.printStackTrace();<br />            }<br />        }<br />    }</pre>
<p>Specifically, if the workDone variable was set to true, we close our socket and break out of the while loop. This means our run method will exit. Of course if workDone is not true, we didn't receive "!" yet, so we go back to check to see if there are more bytes available on the input stream. Finally, we also have to close our try block and catch any exceptions that might have happened in our program; they would have to do with the input/output processing of streams and sockets.</p>
<p>And that's it! We're done. We should be able to launch this on the Android phone now and connect to (and send data back and forth to) the RPi.</p>
<p>Back over in VNC to your RPi, go ahead and start the python script by typing</p>
<pre>sudo python bluetoothtest.py</pre>
<p>(If you ran it earlier and didn't kill it, it might still be running. You can just leave it; it should be fine.)</p>
<p>Then launch the Android app to your Android device. You can't do this through the emulator; you'll have to use the Android device that is paired to the RPi.</p>
<p>Push the button in the Android app and see if you get the message back. You did it! Two way communication!</p>
<h3>[Optional] Connecting through RESTful APIs in the Internet</h3>
<p>Another option that is more complicated but more flexible is to use the RPi's WiFi to connect to a cloud server and store data from the RPi in that cloud server that can then be accessed by any other device (any where in the world!) that has access to that same cloud service. (This is a downside of our bluetooth connection... our Android device has to be "in range" of the RPi to receive the bluetooth messages.)</p>
<p>There are several easy-to-use sites for setting up some data streams; a relatively straightforward one that's free to use is provided over at <a href="https://data.sparkfun.com/">sparkfun</a>. You can take a look at some of their getting start documentation to figure out how to create your own data stream. <a href="https://learn.sparkfun.com/tutorials/pushing-data-to-datasparkfuncom/raspberry-pi-python">Here's</a> an example tailored to the RPi that shows how to push data from the RPi to a sparkfun stream. And <a href="http://phant.io/docs/input/http/">here</a> is some more documentation of phant, which is what lives behind the sparfun streams.</p>
<p>On the Android side, the most popular way for interacting with the JSON objects that will come out of these data stores is through a package called Volley. <a href="https://developer.android.com/training/volley/index.html">Here's</a> the standard Android tutorial on using Volley; basically, once you know the URL where you need to send the request, the hard part is in parsing the JSON data that comes back from the URL. <a href="http://www.thecrazyprogrammer.com/2017/01/android-json-parsing-from-url-example.html">Here's</a> a complete end-to-end example using Volley to process a&nbsp;JSON.</p>
</body> </html>
