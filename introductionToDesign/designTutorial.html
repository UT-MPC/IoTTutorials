<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html> <head>
<title></title>
</head>
<h1>Introduction to Design and Design Documentation</h1>
<h4>Christine Julien, The University of Texas at Austin</h4>
<p>&nbsp;</p>
<p><img style="display: block; margin-left: auto; margin-right: auto;" src="http://www.azquotes.com/picture-quotes/quote-you-know-you-ve-achieved-perfection-in-design-not-when-you-have-nothing-more-to-add-antoine-de-saint-exupery-52-88-88.jpg" /></p>
<h2>What is Good Design?</h2>
<p>Throughout this brief module, keep your Do-It-Yourself assignment in mind. Did you do a good job in design (and in documenting that design)? We'll revisit this at the end of the module.</p>
<p>First, let's talk about design itself, which usually refers to how you structure a complete system, and how you manage the process of building the components of that system.</p>
<p>Consider this (very reasonable) <a href="http://www.theserverside.com/discussions/thread/26021.html">list</a> of elements of good design:</p>
<ul>
<li>Provides the necessary functionality</li>
<li>Is as simple as current and foreseeable constraints will allow</li>
<li>Exhibits maximum cohesion and minimum coupling</li>
<li>Is internally consistent and unsurprising</li>
<li>Eliminates duplication</li>
<li>Is robustly documented</li>
<li>Selects appropriate implementation mechanisms</li>
<li>Is expressed in a precise design language</li>
<li>Considers the sophistication of the team that will implement it</li>
</ul>
<p>We can take each of these in turn, and in so doing learn a lot of fundamentals related to software design.</p>
<h3>Functional</h3>
<p>Clearly, you're writing the software for a reason, and the design should ensure that the software meets that goal. This seems like it would go without saying, but we often get so distracted by design for design's sake (usually trying to make things pretty, or clever, or whatever) that we forget to ensure the desired function first and foremost.</p>
<p>Ensuring that the software (and its design) is functional requires having a robust&nbsp;<em>test suite</em>. That's a whole different topic for an additional module. So let's move on.</p>
<h3>Simple</h3>
<p>There are three related principles here that are worth knowing.</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/KISS_principle"><strong>K.I.S.S.</strong></a> "Keep It Simple Stupid". (Actually originated in systems design in the navy in the 1960s.) This should be a mantra in software design. "<span>The KISS principle states that most systems work best if they are kept simple rather than made complicated; therefore </span><a title="Simplicity" href="https://en.wikipedia.org/wiki/Simplicity">simplicity</a><span> should be a key goal in </span><a title="Design" href="https://en.wikipedia.org/wiki/Design">design</a><span> and unnecessary complexity should be avoided." The key thing to keep in mind is that we're humans, writing software that will have to be maintained by other humans. Debugging and maintaining software are both known to be significantly more challenging than writing the software in the first place.&nbsp;Brian Kernighan, one of the contributors to the development&nbsp;of Unix&nbsp;said, "Debugging is twice as hard as writing the code in the first place. Therefore, if you write the code as cleverly as possible, you are, by definition, not smart enough to debug it."</span></li>
<li><span><strong><a href="https://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it">YAGNI</a>.</strong> "You Aren't Gonna&nbsp;Need It". This is actually one of the tenets of&nbsp;<em>eXtreme Programming</em> (XP), a relatively common software development style. Basically the tenet directs programmers to not add a piece of functionality until it is absolutely necessary.</span></li>
<li><span><strong><a href="https://en.wikipedia.org/wiki/Occam%27s_razor">Occam's Razor</a>.</strong> (aka the "Law of parsimony") It's attributed to William of Ockham (I don't know why there are two different spellings here), who was a Franciscan friar in the 14th century. Basically, it's a theorem that can be stated as "Among competing hypotheses, the one with the fewest assumptions should be selected." The key observation that Occam's razor adds to the very simple "keep it simple" is that simplicity can be defined as having very few assumptions. This can be easily overlooked, so keep a reduction of assumptions in mind.</span></li>
</ul>
<p><span>If we fail to keep these principles in mind, we may end up in the following pitfalls:</span></p>
<ul>
<li><strong><a href="http://en.wikipedia.org/wiki/Feature_creep">Feature creep</a>.</strong>&nbsp;"The ongoing expansion or addition of new features in a product. Extra features go beyond the basic function of the product and so can result in over-complication rather than simple design."</li>
<li><a href="https://en.wikipedia.org/wiki/Software_bloat"><strong>Software bloat.</strong></a> "A process whereby successive versions of a computer program become perceptibly slower, use more memory or processing power, or have higher hardware requirements than the previous version whilst making only dubious user-perceptible improvements."</li>
<li><strong><a href="https://en.wikipedia.org/wiki/Overengineering">Over-engineering.</a>&nbsp;</strong>"T<span>he designing of a product to be more robust or complicated than is necessary for its application, either (charitably) to ensure sufficient </span>factor of safety<span>, sufficient functionality, or because of design errors."</span></li>
</ul>
<h3>High Cohesion and Low Coupling</h3>
<p>First, some terminology.</p>
<p><strong>Modularization&nbsp;</strong>is the process of continuous&nbsp;decomposition of a system until&nbsp;fine-grained components are derived.</p>
<p>An&nbsp;<strong>abstraction</strong> is a view of an object that focuses on the information relevant to a particular purpose and allows one to ignore the other information. For instance&nbsp;<strong>procedural abstraction</strong> allows us to hide the details of a sequence of steps involved in some procedure, simplifying reasoning about the higher level behavior.&nbsp;<strong>Data abstraction</strong> simplifies reasoning about the structure composition of data objects (so we're not always thinking about, for instance, how data is represented in terms of 1s and 0s).</p>
<p><strong>Encapsulation&nbsp;</strong>provides access to services exhibited by abstracted entities by exposing only information relevant to carrying out the particular service(s) and hiding all other information. That is,&nbsp;<strong>information hiding</strong> is the idea of making a component's private parts, well, private, so they can vary independent of any other component that uses the services provided.</p>
<p>In programming, if you make all of the data members of some object&nbsp;<strong>public</strong>, you have failed to hide any information, and you have failed to provide any services that expose just the needed parts of the object.</p>
<p><strong>Coupling</strong> refers to the manner and degree of interdependence between software modules in a system. In general high coupling means the modules are highly dependent on one another, which is usually considered dangerous. When we need to modify one component, the changes can have rippling effects.</p>
<p><strong>Cohesion</strong>, on the other hand, refers to the manner and degree to which the elements of a single module relate to one another. Cohesion can be seen as a measure of how well the design units are put together to accomplish discrete tasks; cohesion is generally considered good because it means that related things are "connected" to one another.</p>
<p>That is, cohesion&nbsp;is the glue that holds modules together, while coupling is the strength of the connections between the modules.</p>
<p><img style="display: block; margin-left: auto; margin-right: auto;" src="https://utexas.instructure.com/courses/1198798/files/42561498/preview" alt="CouplingAndCohesion.png" width="434" height="165" data-api-endpoint="https://utexas.instructure.com/api/v1/courses/1198798/files/42561498" data-api-returntype="File" /></p>
<h3>Internally Consistent</h3>
<p>In practice, every company adheres to a "style guide" that ensures that the code base for the company (which can be really really large) is internally consistent. When this is the case, anyone familiar with the style and perusing the code is less likely to be surprised by how things are done and is more likely to be able to easily navigate the code to understand it, modify it, or extend it. For instance, to contribute to the Android codebase, one must adhere to <a href="https://source.android.com/source/code-style">this</a> style guide. It's worth clicking on that link and taking a look at what some of the "rules" are. They vary from the mundane (e.g., how many spaces make up an indentation on a line) to good programming practice (e.g., keep method bodies small).</p>
<p>Google (the company) has <a href="https://github.com/google/styleguide">style guides</a> for each of its major languages, e.g.,&nbsp;<a href="https://google.github.io/styleguide/cppguide.html">C++</a>, <a href="https://google.github.io/styleguide/javaguide.html">Java</a>, <a href="https://google.github.io/styleguide/pyguide.html">Python</a>. They even have an <a href="https://github.com/google/styleguide/tree/gh-pages/cpplint">tool</a> that will automatically check whether a C++ program adheres to the style.</p>
<p>These are, of course, just examples from Google; other companies have their own style guides which may have some differences from the Google style guides. The important thing is that, within the company, the codebase is consistent.</p>
<h3>Avoids Duplication</h3>
<p>One of the things programmers are taught early is that copying and pasting code is a bad idea. Why? If it turns out there's a bug in the thing you duplicated, you'll have to find every instance and fix it. You'll always miss one. It's a pain. But avoiding duplication goes further.</p>
<p><a href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself">The DRY&nbsp;Principle</a> ("Don't Repeat Yourself") captures the sentiment that "e<span>very piece of knowledge must have a single, unambiguous, authoritative representation within a system". Because software engineers like to think they're funny, the opposite of a DRY system is a WET system (for "Write Everything Twice" or "We Enjoy Typing" or "Waste Everyone's Time"). When a system is DRY, any modification you make to the code does not require any other modification in a logically unrelated part of the code. Further, for elements that&nbsp;<em>are</em> logically connected, they are guaranteed to change in sync.&nbsp;</span></p>
<h3>Robustly Documented</h3>
<p>Documenting a software system is boring. However, if it's not done, maintenance of that system is nearly impossible. Too many times we write a piece of reasonably complex code and then come back to it a week, a month, a year later and have no idea what we were doing or why. And documentation doesn't apply to just the code, it also applies to design decisions as well. Why did you decide to structure your system in this way? Why did you not choose this other option, which, on the surface, seems like a better idea?</p>
<p>You should consider having (formal) documentation of all of the following forms:</p>
<ul>
<li><a title="Requirement" href="https://en.wikipedia.org/wiki/Requirement">Requirements</a><span> document what the software system should do. We generally consider the requirements documentation something of a&nbsp;<em>contract</em> for the system. Requirements can be stated at a variety of levels (e.g., generic goals vs. design constraints) and can be written in a variety of ways (e.g., natural language vs. mathematical formulas).</span></li>
<li><span><a href="https://en.wikipedia.org/wiki/Software_architecture_description">Architecture</a> documents start to map the general requirements onto the overall architecture of the system. The goal is not to say how a specific routine or function is implemented (or, really, even if that routine or function exists) but rather how the requirements of the system are captured in components and how those components relate to one another.&nbsp;</span></li>
<li><span><a href="https://en.wikipedia.org/wiki/Technical_documentation">Technical</a> documentation is associated with the actual artifacts (code) to explain how and why it works. The most common form of technical documentation is comments in code. API documentation (e.g., the services exposed by the system and how they are employed) are also important. There are lots of tools to help automate the process of technical documentation generation (<a href="https://en.wikipedia.org/wiki/Doxygen">Doxygen</a> is the most popular).</span></li>
<li><span>User documentation describes how the software is used. Depending on the sophistication of the system, this documentation will vary in length. But it usually takes the form of some kind of "user manual" and/or help pages. There is often some additional "installation" and "setup" instructions.</span></li>
</ul>
<h3><span></span>Selects Appropriate Implementation Mechanisms</h3>
<p>In classes, the implementation mechanisms (often programming language, but also libraries, tools, backend services, etc.) to use will be specified for you. In the real world, though, this is one of the major decision points. It's really easy to fall into a trap of using what you know or what you're good at (which should be&nbsp;<strong>a</strong> consideration but not&nbsp;<strong>the</strong> only one). For instance, for your project for this course, will you use Bluetooth communication between the RPi and the Android device or will you use some RESTful service in the Internet to share information? The decision should be based at least partially on your design. For instance, will the RPi and the Android device always be within Bluetooth range for all use cases of your application?</p>
<h3>Expressed in Precise Design Language</h3>
<p>The most well known language for describing a software design is the <a href="https://en.wikipedia.org/wiki/Unified_Modeling_Language">Unified Modeling Language</a> (UML). There are some things not to love about UML, but it can be really useful in other cases. At the core, though, UML provides a set of styles of diagrams for expressing design. There are two categories of diagrams: structural ones and behavioral ones.</p>
<p>"<span>Structure diagrams emphasize the things that must be present in the system being modeled." The most common examples of UML structure diagrams are <a href="https://en.wikipedia.org/wiki/Component_diagram">component diagrams</a> and <a href="https://en.wikipedia.org/wiki/Class_diagram">class diagrams</a>. A component diagram "depicts how components are wired together to form larger components or software systems". <a href="http://www.conceptdraw.com/samples/resource/images/solutions/uml-diagrams/UML-DIAGRAMS-UML-Component-Diagram.png">Here</a> is an example. A class diagram "describes the structure of a system by showing the system's classes, their attributes, operations (or methods), and the relationships among objects." <a href="http://www.conceptdraw.com/samples/resource/images/solutions/uml-diagrams/UML%20Class%20Diagram.jpg">Here</a> is an example.</span></p>
<p><span>"Behavior diagrams emphasize what must happen in the system being modeled." My two favorites are the <a href="https://en.wikipedia.org/wiki/Activity_diagram">activity diagram</a> and the <a href="https://en.wikipedia.org/wiki/Sequence_diagram">sequence diagram</a>. Activity diagrams "are graphical representations of workflows of stepwise activities and actions&nbsp;with support for choice, iteration and concurrency." <a href="https://en.wikipedia.org/wiki/Activity_diagram#/media/File:Activity_conducting.svg">Here</a> is an example. A sequence diagram "shows how objects operate with one another and in what order. It is a construct of a message sequence chart". <a href="https://en.wikipedia.org/wiki/Sequence_diagram#/media/File:CheckEmail.svg">Here</a> is an example.</span></p>
<h3>Considers the Team</h3>
<p>Obviously, you want to build the "right" team to build the system you need. However, it is crucial that your design also consider the expertise available to you. Certainly, some elements of the design or implementation are non-negotiable (e.g., if you want to build an "app" but don't have any programming expertise, there's not a lot you can do). On the other hand, some gaps in team knowledge or skills can be "designed around" if they're considered at the outset.</p>
<h3>Assignment</h3>
<p>Let's now revisit the Do-It-Yourself assignment where we took a crack at documenting a design without really knowing what we were doing. Let's briefly redo this assignment. Specifically, restructure your document&nbsp;(and your code!) to do (at least) the following:</p>
<ul>
<li>Explicitly state/provide the requirements, architecture, technical, and user documentation.</li>
<li><a href="https://en.wikipedia.org/wiki/Code_refactoring">Refactor</a> your code to adhere&nbsp;to the Google Java style guide (for the Android code) and the Google Python style guide (for the Python code).</li>
<li>Provide either (1) a UML-style sequence diagram showing the sequence of behaviors upon the user clicking one of the app's buttons or (2) a UML-style activity diagram showing the overall user interaction with the entire system.</li>
</ul>
<p>Submit a PDF of your revised design document here:&nbsp;<a title="Design Assignment (Do-It-Yourself Take 2)" href="https://utexas.instructure.com/courses/1198798/assignments/4099981" data-api-endpoint="https://utexas.instructure.com/api/v1/courses/1198798/assignments/4099981" data-api-returntype="Assignment">Design Assignment (Do-It-Yourself Take 2)</a>.</p>
<p>&nbsp;</p>
</body> </html>
